diff -Naur freetype-2.4.2.orig/src/bdf/bdflib.c freetype-2.4.2/src/bdf/bdflib.c
--- freetype-2.4.2.orig/src/bdf/bdflib.c	2010-07-12 21:06:02.000000000 +0200
+++ freetype-2.4.2/src/bdf/bdflib.c	2012-03-07 16:15:57.840165801 +0100
@@ -1585,6 +1585,11 @@
 
       p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );
 
+      /* Normalize negative encoding values.  The specification only */
+      /* allows -1, but we can be more generous here.                */
+      if ( p->glyph_enc < -1 )
+        p->glyph_enc = -1;
+
       /* Check that the encoding is in the range [0,65536] because        */
       /* otherwise p->have (a bitmap with static size) overflows.         */
       if ( (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )
@@ -1728,12 +1733,7 @@
     if ( ft_memcmp( line, "SWIDTH", 6 ) == 0 )
     {
       if ( !( p->flags & _BDF_ENCODING ) )
-      {
-        /* Missing ENCODING field. */
-        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
-        error = BDF_Err_Missing_Encoding_Field;
-        goto Exit;
-      }
+        goto Missing_Encoding;
 
       error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
@@ -1748,6 +1748,9 @@
     /* Expect the DWIDTH (scalable width) field next. */
     if ( ft_memcmp( line, "DWIDTH", 6 ) == 0 )
     {
+      if ( !( p->flags & _BDF_ENCODING ) )
+        goto Missing_Encoding;
+
       error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
@@ -1773,6 +1776,9 @@
     /* Expect the BBX field next. */
     if ( ft_memcmp( line, "BBX", 3 ) == 0 )
     {
+      if ( !( p->flags & _BDF_ENCODING ) )
+        goto Missing_Encoding;
+
       error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
       if ( error )
         goto Exit;
@@ -1872,6 +1878,12 @@
     }
 
     error = BDF_Err_Invalid_File_Format;
+    goto Exit;
+
+  Missing_Encoding:
+    /* Missing ENCODING field. */
+    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
+    error = BDF_Err_Missing_Encoding_Field;
 
   Exit:
     if ( error && ( p->flags & _BDF_GLYPH ) )
diff -Naur freetype-2.4.2.orig/src/truetype/ttgload.c freetype-2.4.2/src/truetype/ttgload.c
--- freetype-2.4.2.orig/src/truetype/ttgload.c	2010-06-29 10:27:12.000000000 +0200
+++ freetype-2.4.2/src/truetype/ttgload.c	2012-03-07 16:14:34.604215007 +0100
@@ -379,14 +379,17 @@
     if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
       goto Invalid_Outline;
 
-    prev_cont = FT_NEXT_USHORT( p );
+    prev_cont = FT_NEXT_SHORT( p );
 
     if ( n_contours > 0 )
       cont[0] = prev_cont;
 
+    if ( prev_cont < 0 )
+      goto Invalid_Outline;
+
     for ( cont++; cont < cont_limit; cont++ )
     {
-      cont[0] = FT_NEXT_USHORT( p );
+      cont[0] = FT_NEXT_SHORT( p );
       if ( cont[0] <= prev_cont )
       {
         /* unordered contours: this is invalid */
diff -Naur freetype-2.4.2.orig/src/type1/t1parse.c freetype-2.4.2/src/type1/t1parse.c
--- freetype-2.4.2.orig/src/type1/t1parse.c	2009-11-25 23:46:15.000000000 +0100
+++ freetype-2.4.2/src/type1/t1parse.c	2012-03-07 16:13:42.276665992 +0100
@@ -467,6 +467,14 @@
     /* we now decrypt the encoded binary private dictionary */
     psaux->t1_decrypt( parser->private_dict, parser->private_len, 55665U );
 
+    if ( parser->private_len < 4 )
+    {
+      FT_ERROR(( "T1_Get_Private_Dict:"
+                 " invalid private dictionary section\n" ));
+      error = T1_Err_Invalid_File_Format;
+      goto Fail;
+    }
+
     /* replace the four random bytes at the beginning with whitespace */
     parser->private_dict[0] = ' ';
     parser->private_dict[1] = ' ';
diff -Naur freetype-2.4.2.orig/src/winfonts/winfnt.c freetype-2.4.2/src/winfonts/winfnt.c
--- freetype-2.4.2.orig/src/winfonts/winfnt.c	2010-07-10 15:03:09.000000000 +0200
+++ freetype-2.4.2/src/winfonts/winfnt.c	2012-03-07 16:14:23.012665666 +0100
@@ -827,7 +827,14 @@
           root->charmap = root->charmaps[0];
       }
 
-      /* setup remaining flags */
+      /* set up remaining flags */
+
+      if ( font->header.last_char < font->header.first_char )
+      {
+        FT_TRACE2(( "invalid number of glyphs\n" ));
+        error = FNT_Err_Invalid_File_Format;
+        goto Fail;
+      }
 
       /* reserve one slot for the .notdef glyph at index 0 */
       root->num_glyphs = font->header.last_char -
